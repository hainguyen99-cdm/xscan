"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/obs-settings/page",{

/***/ "(app-pages-browser)/./src/lib/s3-upload.service.ts":
/*!**************************************!*\
  !*** ./src/lib/s3-upload.service.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S3UploadService: function() { return /* binding */ S3UploadService; }\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./src/lib/api.ts\");\n\nclass S3UploadService {\n    /**\n   * Upload a single file to S3\n   */ static async uploadFile(file, onProgress) {\n        const token = (0,_api__WEBPACK_IMPORTED_MODULE_0__.getStoredToken)();\n        if (!token) {\n            throw new Error(\"Authentication required. Please log in again.\");\n        }\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"mediaType\", file.type);\n        return new Promise((resolve, reject)=>{\n            const xhr = new XMLHttpRequest();\n            // Track upload progress\n            if (onProgress) {\n                xhr.upload.addEventListener(\"progress\", (event)=>{\n                    if (event.lengthComputable) {\n                        const percentage = Math.round(event.loaded * 100 / event.total);\n                        onProgress({\n                            loaded: event.loaded,\n                            total: event.total,\n                            percentage\n                        });\n                    }\n                });\n            }\n            xhr.addEventListener(\"load\", ()=>{\n                console.log(\"S3 Upload Response:\", {\n                    status: xhr.status,\n                    statusText: xhr.statusText,\n                    responseText: xhr.responseText\n                });\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    try {\n                        const response = JSON.parse(xhr.responseText);\n                        console.log(\"Parsed response:\", response);\n                        if (response.success) {\n                            resolve(response.data);\n                        } else {\n                            reject(new Error(response.error || \"Upload failed\"));\n                        }\n                    } catch (error) {\n                        console.error(\"JSON parse error:\", error);\n                        reject(new Error(\"Invalid response from server\"));\n                    }\n                } else {\n                    try {\n                        const errorResponse = JSON.parse(xhr.responseText);\n                        reject(new Error(errorResponse.error || \"Upload failed with status \".concat(xhr.status)));\n                    } catch (e) {\n                        reject(new Error(\"Upload failed with status \".concat(xhr.status)));\n                    }\n                }\n            });\n            xhr.addEventListener(\"error\", ()=>{\n                reject(new Error(\"Network error during upload\"));\n            });\n            xhr.addEventListener(\"timeout\", ()=>{\n                reject(new Error(\"Upload timeout\"));\n            });\n            xhr.open(\"POST\", this.UPLOAD_ENDPOINT);\n            xhr.setRequestHeader(\"Authorization\", \"Bearer \".concat(token));\n            xhr.timeout = 300000; // 5 minutes timeout\n            xhr.send(formData);\n        });\n    }\n    /**\n   * Upload multiple files to S3\n   */ static async uploadMultipleFiles(files, onProgress) {\n        const results = [];\n        for(let i = 0; i < files.length; i++){\n            const file = files[i];\n            const progressCallback = onProgress ? (progress)=>onProgress(i, progress) : undefined;\n            try {\n                const result = await this.uploadFile(file, progressCallback);\n                results.push(result);\n            } catch (error) {\n                console.error(\"Failed to upload file \".concat(file.name, \":\"), error);\n                throw new Error(\"Failed to upload \".concat(file.name, \": \").concat(error.message));\n            }\n        }\n        return results;\n    }\n    /**\n   * Check if a URL is an S3 URL or CDN URL\n   */ static isS3Url(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.hostname.includes(\"s3\") || urlObj.hostname.includes(\"amazonaws.com\") || urlObj.hostname === \"cdn.xscan.top\";\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * Check if a URL is a base64 data URL\n   */ static isBase64DataUrl(url) {\n        return url && url.startsWith(\"data:\") && url.includes(\"base64,\");\n    }\n    /**\n   * Convert S3 URL to CDN URL\n   */ static convertToCdnUrl(s3Url) {\n        try {\n            const urlObj = new URL(s3Url);\n            if (urlObj.hostname.includes(\"s3\") && urlObj.hostname.includes(\"amazonaws.com\")) {\n                const key = urlObj.pathname.substring(1); // Remove leading slash\n                return \"https://cdn.xscan.top/\".concat(key);\n            }\n            return s3Url; // Return original if not an S3 URL\n        } catch (error) {\n            console.warn(\"Failed to convert S3 URL to CDN URL: \".concat(s3Url));\n            return s3Url;\n        }\n    }\n    /**\n   * Validate file before upload\n   */ static validateFile(file) {\n        // Check file size (50MB limit)\n        if (file.size > 50 * 1024 * 1024) {\n            return {\n                isValid: false,\n                error: \"File size must be under 50MB. Your file is \".concat((file.size / (1024 * 1024)).toFixed(1), \"MB.\")\n            };\n        }\n        // Check file type\n        const supportedTypes = [\n            \"image/jpeg\",\n            \"image/jpg\",\n            \"image/png\",\n            \"image/gif\",\n            \"image/webp\",\n            \"video/mp4\",\n            \"video/webm\",\n            \"audio/mpeg\",\n            \"audio/mp3\",\n            \"audio/wav\",\n            \"audio/ogg\"\n        ];\n        if (!supportedTypes.includes(file.type)) {\n            return {\n                isValid: false,\n                error: \"Unsupported file type. Supported formats: Images (JPG, PNG, GIF, WebP), Videos (MP4, WebM), Audio (MP3, WAV, OGG)\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n}\nS3UploadService.UPLOAD_ENDPOINT = \"/api/obs-settings/media/upload\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvczMtdXBsb2FkLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFnQmhDLE1BQU1DO0lBR1g7O0dBRUMsR0FDRCxhQUFhQyxXQUNYQyxJQUFVLEVBQ1ZDLFVBQStDLEVBQ3hCO1FBQ3ZCLE1BQU1DLFFBQVFMLG9EQUFjQTtRQUM1QixJQUFJLENBQUNLLE9BQU87WUFDVixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxXQUFXLElBQUlDO1FBQ3JCRCxTQUFTRSxNQUFNLENBQUMsUUFBUU47UUFDeEJJLFNBQVNFLE1BQU0sQ0FBQyxhQUFhTixLQUFLTyxJQUFJO1FBRXRDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixNQUFNQyxNQUFNLElBQUlDO1lBRWhCLHdCQUF3QjtZQUN4QixJQUFJWCxZQUFZO2dCQUNkVSxJQUFJRSxNQUFNLENBQUNDLGdCQUFnQixDQUFDLFlBQVksQ0FBQ0M7b0JBQ3ZDLElBQUlBLE1BQU1DLGdCQUFnQixFQUFFO3dCQUMxQixNQUFNQyxhQUFhQyxLQUFLQyxLQUFLLENBQUMsTUFBT0MsTUFBTSxHQUFHLE1BQU9MLE1BQU1NLEtBQUs7d0JBQ2hFcEIsV0FBVzs0QkFDVG1CLFFBQVFMLE1BQU1LLE1BQU07NEJBQ3BCQyxPQUFPTixNQUFNTSxLQUFLOzRCQUNsQko7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBTixJQUFJRyxnQkFBZ0IsQ0FBQyxRQUFRO2dCQUMzQlEsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QjtvQkFDakNDLFFBQVFiLElBQUlhLE1BQU07b0JBQ2xCQyxZQUFZZCxJQUFJYyxVQUFVO29CQUMxQkMsY0FBY2YsSUFBSWUsWUFBWTtnQkFDaEM7Z0JBRUEsSUFBSWYsSUFBSWEsTUFBTSxJQUFJLE9BQU9iLElBQUlhLE1BQU0sR0FBRyxLQUFLO29CQUN6QyxJQUFJO3dCQUNGLE1BQU1HLFdBQVdDLEtBQUtDLEtBQUssQ0FBQ2xCLElB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NkIsT0FBSkY7WUFDbEM7WUFDQSxPQUFPRCxPQUFPLG1DQUFtQztRQUNuRCxFQUFFLE9BQU81QixPQUFPO1lBQ2RWLFFBQVEwQyxJQUFJLENBQUMsd0NBQThDLE9BQU5KO1lBQ3JELE9BQU9BO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBT0ssYUFBYWpFLElBQVUsRUFBd0M7UUFDcEUsK0JBQStCO1FBQy9CLElBQUlBLEtBQUtrRSxJQUFJLEdBQUcsS0FBSyxPQUFPLE1BQU07WUFDaEMsT0FBTztnQkFDTEMsU0FBUztnQkFDVG5DLE9BQU8sOENBQXFGLE9BQXZDLENBQUNoQyxLQUFLa0UsSUFBSSxHQUFJLFFBQU8sSUFBRyxDQUFDLEVBQUdFLE9BQU8sQ0FBQyxJQUFHO1lBQzlGO1FBQ0Y7UUFFQSxrQkFBa0I7UUFDbEIsTUFBTUMsaUJBQWlCO1lBQ3JCO1lBQWM7WUFBYTtZQUFhO1lBQWE7WUFDckQ7WUFBYTtZQUNiO1lBQWM7WUFBYTtZQUFhO1NBQ3pDO1FBRUQsSUFBSSxDQUFDQSxlQUFlYixRQUFRLENBQUN4RCxLQUFLTyxJQUFJLEdBQUc7WUFDdkMsT0FBTztnQkFDTDRELFNBQVM7Z0JBQ1RuQyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87WUFBRW1DLFNBQVM7UUFBSztJQUN6QjtBQUNGO0FBL0thckUsZ0JBQ2FxQyxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zMy11cGxvYWQuc2VydmljZS50cz81NzdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFN0b3JlZFRva2VuIH0gZnJvbSAnLi9hcGknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFJlc3VsdCB7XG4gIHVybDogc3RyaW5nO1xuICBzM0tleTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFByb2dyZXNzIHtcbiAgbG9hZGVkOiBudW1iZXI7XG4gIHRvdGFsOiBudW1iZXI7XG4gIHBlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFMzVXBsb2FkU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFVQTE9BRF9FTkRQT0lOVCA9ICcvYXBpL29icy1zZXR0aW5ncy9tZWRpYS91cGxvYWQnO1xuXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBzaW5nbGUgZmlsZSB0byBTM1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIHVwbG9hZEZpbGUoXG4gICAgZmlsZTogRmlsZSxcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBVcGxvYWRQcm9ncmVzcykgPT4gdm9pZFxuICApOiBQcm9taXNlPFVwbG9hZFJlc3VsdD4ge1xuICAgIGNvbnN0IHRva2VuID0gZ2V0U3RvcmVkVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLiBQbGVhc2UgbG9nIGluIGFnYWluLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdtZWRpYVR5cGUnLCBmaWxlLnR5cGUpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAvLyBUcmFjayB1cGxvYWQgcHJvZ3Jlc3NcbiAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE1hdGgucm91bmQoKGV2ZW50LmxvYWRlZCAqIDEwMCkgLyBldmVudC50b3RhbCk7XG4gICAgICAgICAgICBvblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICAgIHRvdGFsOiBldmVudC50b3RhbCxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnUzMgVXBsb2FkIFJlc3BvbnNlOicsIHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgcmVzcG9uc2VUZXh0OiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnVXBsb2FkIGZhaWxlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSlNPTiBwYXJzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yUmVzcG9uc2UuZXJyb3IgfHwgYFVwbG9hZCBmYWlsZWQgd2l0aCBzdGF0dXMgJHt4aHIuc3RhdHVzfWApKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQgd2l0aCBzdGF0dXMgJHt4aHIuc3RhdHVzfWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3IgZHVyaW5nIHVwbG9hZCcpKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVXBsb2FkIHRpbWVvdXQnKSk7XG4gICAgICB9KTtcblxuICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB0aGlzLlVQTE9BRF9FTkRQT0lOVCk7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgIHhoci50aW1lb3V0ID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXMgdGltZW91dFxuXG4gICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIG11bHRpcGxlIGZpbGVzIHRvIFMzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBsb2FkTXVsdGlwbGVGaWxlcyhcbiAgICBmaWxlczogRmlsZVtdLFxuICAgIG9uUHJvZ3Jlc3M/OiAoZmlsZUluZGV4OiBudW1iZXIsIHByb2dyZXNzOiBVcGxvYWRQcm9ncmVzcykgPT4gdm9pZFxuICApOiBQcm9taXNlPFVwbG9hZFJlc3VsdFtdPiB7XG4gICAgY29uc3QgcmVzdWx0czogVXBsb2FkUmVzdWx0W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV07XG4gICAgICBjb25zdCBwcm9ncmVzc0NhbGxiYWNrID0gb25Qcm9ncmVzcyA/IChwcm9ncmVzczogVXBsb2FkUHJvZ3Jlc3MpID0+IG9uUHJvZ3Jlc3MoaSwgcHJvZ3Jlc3MpIDogdW5kZWZpbmVkO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwbG9hZEZpbGUoZmlsZSwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwbG9hZCBmaWxlICR7ZmlsZS5uYW1lfTpgLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwbG9hZCAke2ZpbGUubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBVUkwgaXMgYW4gUzMgVVJMIG9yIENETiBVUkxcbiAgICovXG4gIHN0YXRpYyBpc1MzVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHVybE9iai5ob3N0bmFtZS5pbmNsdWRlcygnczMnKSB8fCBcbiAgICAgICAgdXJsT2JqLmhvc3RuYW1lLmluY2x1ZGVzKCdhbWF6b25hd3MuY29tJykgfHxcbiAgICAgICAgdXJsT2JqLmhvc3RuYW1lID09PSAnY2RuLnhzY2FuLnRvcCdcbiAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgVVJMIGlzIGEgYmFzZTY0IGRhdGEgVVJMXG4gICAqL1xuICBzdGF0aWMgaXNCYXNlNjREYXRhVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHVybCAmJiB1cmwuc3RhcnRzV2l0aCgnZGF0YTonKSAmJiB1cmwuaW5jbHVkZXMoJ2Jhc2U2NCwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IFMzIFVSTCB0byBDRE4gVVJMXG4gICAqL1xuICBzdGF0aWMgY29udmVydFRvQ2RuVXJsKHMzVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHMzVXJsKTtcbiAgICAgIGlmICh1cmxPYmouaG9zdG5hbWUuaW5jbHVkZXMoJ3MzJykgJiYgdXJsT2JqLmhvc3RuYW1lLmluY2x1ZGVzKCdhbWF6b25hd3MuY29tJykpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXJsT2JqLnBhdGhuYW1lLnN1YnN0cmluZygxKTsgLy8gUmVtb3ZlIGxlYWRpbmcgc2xhc2hcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2Nkbi54c2Nhbi50b3AvJHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzM1VybDsgLy8gUmV0dXJuIG9yaWdpbmFsIGlmIG5vdCBhbiBTMyBVUkxcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY29udmVydCBTMyBVUkwgdG8gQ0ROIFVSTDogJHtzM1VybH1gKTtcbiAgICAgIHJldHVybiBzM1VybDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgZmlsZSBiZWZvcmUgdXBsb2FkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVGaWxlKGZpbGU6IEZpbGUpOiB7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICAgIC8vIENoZWNrIGZpbGUgc2l6ZSAoNTBNQiBsaW1pdClcbiAgICBpZiAoZmlsZS5zaXplID4gNTAgKiAxMDI0ICogMTAyNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgRmlsZSBzaXplIG11c3QgYmUgdW5kZXIgNTBNQi4gWW91ciBmaWxlIGlzICR7KGZpbGUuc2l6ZSAvICgxMDI0ICogMTAyNCkpLnRvRml4ZWQoMSl9TUIuYFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmaWxlIHR5cGVcbiAgICBjb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcbiAgICAgICdpbWFnZS9qcGVnJywgJ2ltYWdlL2pwZycsICdpbWFnZS9wbmcnLCAnaW1hZ2UvZ2lmJywgJ2ltYWdlL3dlYnAnLFxuICAgICAgJ3ZpZGVvL21wNCcsICd2aWRlby93ZWJtJyxcbiAgICAgICdhdWRpby9tcGVnJywgJ2F1ZGlvL21wMycsICdhdWRpby93YXYnLCAnYXVkaW8vb2dnJ1xuICAgIF07XG5cbiAgICBpZiAoIXN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZS4gU3VwcG9ydGVkIGZvcm1hdHM6IEltYWdlcyAoSlBHLCBQTkcsIEdJRiwgV2ViUCksIFZpZGVvcyAoTVA0LCBXZWJNKSwgQXVkaW8gKE1QMywgV0FWLCBPR0cpJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXRTdG9yZWRUb2tlbiIsIlMzVXBsb2FkU2VydmljZSIsInVwbG9hZEZpbGUiLCJmaWxlIiwib25Qcm9ncmVzcyIsInRva2VuIiwiRXJyb3IiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwidHlwZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ1cGxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJsZW5ndGhDb21wdXRhYmxlIiwicGVyY2VudGFnZSIsIk1hdGgiLCJyb3VuZCIsImxvYWRlZCIsInRvdGFsIiwiY29uc29sZSIsImxvZyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsIkpTT04iLCJwYXJzZSIsInN1Y2Nlc3MiLCJkYXRhIiwiZXJyb3IiLCJlcnJvclJlc3BvbnNlIiwib3BlbiIsIlVQTE9BRF9FTkRQT0lOVCIsInNldFJlcXVlc3RIZWFkZXIiLCJ0aW1lb3V0Iiwic2VuZCIsInVwbG9hZE11bHRpcGxlRmlsZXMiLCJmaWxlcyIsInJlc3VsdHMiLCJpIiwibGVuZ3RoIiwicHJvZ3Jlc3NDYWxsYmFjayIsInByb2dyZXNzIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicHVzaCIsIm5hbWUiLCJtZXNzYWdlIiwiaXNTM1VybCIsInVybCIsInVybE9iaiIsIlVSTCIsImhvc3RuYW1lIiwiaW5jbHVkZXMiLCJpc0Jhc2U2NERhdGFVcmwiLCJzdGFydHNXaXRoIiwiY29udmVydFRvQ2RuVXJsIiwiczNVcmwiLCJrZXkiLCJwYXRobmFtZSIsInN1YnN0cmluZyIsIndhcm4iLCJ2YWxpZGF0ZUZpbGUiLCJzaXplIiwiaXNWYWxpZCIsInRvRml4ZWQiLCJzdXBwb3J0ZWRUeXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/s3-upload.service.ts\n"));

/***/ })

});